import requests

# Arrumar esse codigo na parte dos escopos para que não fique tão fechado assim
# Talvez mudar variaveis que se repetem para variaveis self e modificar elas com globais
# Da para melhorar get_clip depois igual o de users, mas são muitos parametros, então vou com calma

API_URL_BASE = "https://api.twitch.tv/helix"

CHAT_SCOPE = "/chat/messages" # Não são os scopes
CLIP_SCOPE = "/clips"
USER_SCOPE = "/users"

class TwitchClipAPI():
    headers = {}
    user_data = {}
    clip_data = {}
    chat_message_data = {}
    created_clip_data = {}

    def __init__(self, client_id: str, token: str) -> None:
        """
        Creates a :class:`TwitchClipAPI`.

        Args:
            client_id (str): The id of de client API.
            token (str): The token generated by oauth.       
        """

        # Create header to requests
        self.headers = {
            'Authorization': f'Bearer {token}',
            'Client-Id': client_id}
    
    def users_info(self, usernames: list = None, ids: list = None) -> dict:
        """
        Search for users:
        
        Args:
            usernames (list[(str)] = None: Must be a list of 
            string with maximum of 100 usernames. 
            ids (list[(str)] = None: Must be a list of string 
            with maximum of 100 ids.

        In case use both parameters 'usernames' and 'ids', the 
        maximum itens of the list drops to 50 each.

        Returns:
            Users info.
        """
        
        # Verify username parameter are used and construct 
        # the string to append with url of request
        # example: ?login=<username>&login=<username>
        if usernames != None:
            if len(usernames) <= 100:
                url_data = "?login="+usernames[0]

                if len(usernames) > 1:
                    for username in usernames[1:]:
                        url_data += "&login="+username
            else:
                raise Exception("Number of usernames exced the maximum")

        # Same for ids
        if ids != None:
            if len(ids) <= 100:
                url_data = "?id="+ids[0]    
                
                if len(ids) > 1:
                    for id in ids[1:]:
                        url_data += "&id="+id
            else:
                raise Exception("Number of ids exced the maximum")

        # In case of use both parameters, construct one string
        # example: ?login=<username>&login=<username>&id=<id>&id=<id>
        if usernames != None and ids != None:
            if len(usernames) <= 50 and len(ids) <= 50:
                
                url_data = "?login="+usernames[0]
                if len(usernames) > 1:
                    for username in usernames[1:]:
                        url_data += "&login="+username
                
                url_data += "&id="+ids[0]
                if len(ids) > 1:
                    for id in ids[1:]:
                        url_data += "&id="+id
            else:
                raise Exception("Number of usernames and ids exced the maximum")

        url = API_URL_BASE + USER_SCOPE + url_data

        r = requests.get(url=url, headers=self.headers)

        # Return response case of success
        if r.status_code == 200:
            self.user_data = r.json()
            return self.user_data['data']

        # Raise errors codes        
        if r.status_code == 400:
            raise Exception("HTTPS response error:\n Bad request with wrong parameters")
        if r.status_code == 401:
            raise Exception("HTTPS response error:\n Invalid access token, client id or scopes")
    
    def create_clip(self, broadcaster_id: str, has_delay: bool = False) -> dict:
        """
        Create a clip in the broadcaster channel:
        
        Args:
            broadcaster_id (str): Must be id of the broadcaster 
            channel wich will be created a clip. 
            has_delay (bool) = False: Creat a clip in the moment 
            of request in case of False, else, twitch add a delay 
            betwen request and the creation.

        Returns:
            Createed clip info.
        """
        url = API_URL_BASE + CLIP_SCOPE

        # Construc params
        params = {
            'broadcaster_id' : broadcaster_id,
            'has_delay' : has_delay
        }

        # make the request
        r = requests.post(url, params=params, headers=self.headers)

        # Return value in case of success
        if r.status_code == 202:
            self.created_clip_data = r.json()
            return self.created_clip_data['data'][0]
        
        # Error codes
        if r.status_code == 400:
            raise Exception("HTTPS response error:\n Bad request with wrong parameters")
        if r.status_code == 401:
            raise Exception("HTTPS response error:\n Invalid access token, client id or scopes")
        if r.status_code == 403:
            raise Exception("HTTPS response error:\n Can't make clips of this broadcaster")
        if r.status_code == 404:
            raise Exception("HTTPS response error:\n Broadcaster must be in live")
    
    def get_clip(self, clip_id: str) -> dict:
        """
        Get a clip:
        
        Args:
            clip_id (str): Must be id of the clip. 

        Returns:
            Clip info.
        """
        
        url = API_URL_BASE + CLIP_SCOPE
        # cosntruct params
        params = {
            'id' : clip_id
        }

        r = requests.get(url, params=params, headers=self.headers)
        
        # Return data in case of success
        if r.status_code == 200:
            self.clip_data = r.json()
            return self.clip_data['data']
        
        # Error codes
        if r.status_code == 400:
            raise Exception("HTTPS response error:\n Bad request with wrong parameters")        
        if r.status_code == 401:
            raise Exception("HTTPS response error:\n Invalid access token, client id or scopes")
        
    def send_chat_message(self, broadcaster_id: str, sender_id: str, msg: str) -> dict:
        """
        Send a chat message:
        
        Args:
            broadcaster_id (str): Must be id of the broadcaster 
            channel wich will be send a chat message. 
            sender_id (str): Must be id of the user wich will be 
            sending a chat message.
            msg (str): The message chat itself  

        Returns:
            Send message info.
        """
        url = API_URL_BASE + CHAT_SCOPE
        
        # Construct params
        params = {
            'broadcaster_id' : broadcaster_id,
            'sender_id' : sender_id,
            'message' : msg
        }

        # Change content type of headers
        headers = self.headers
        headers['Content-Type'] = 'application/json'

        # Make request
        r = requests.post(url, params=params, headers=headers)
        
        # Return data in case of success
        if r.status_code == 200:
            self.chat_message_data = r.json()
            return self.chat_message_data['data']
                
        # Error codes
        if r.status_code == 400:
            raise Exception("HTTPS response error:\n Bad request with wrong parameters")
        if r.status_code == 401:
            raise Exception("HTTPS response error:\n Invalid access token, client id or scopes")
        if r.status_code == 403:
            raise Exception("HTTPS response error:\n Can't send chat messages to this broadcaster")
        if r.status_code == 422:
            raise Exception("HTTPS response error:\n Message too large to send")
        
    
# Checklist das funções:
# __init__ - OK
# users_info - OK
# create_clip - OK
# get_clip - OK (melhorar)
# send_chat_message - OK (melhorar)


    
        
